<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Silkscreen:wght@400;700&display=swap" rel="stylesheet">
<title>10second</title>
<style>
  :root {
    --bg: #000;
    --fg: #fff;
    --accent: rgb(214, 235, 25); /* 勝者の赤（仕様に合わせて使用） */
    --border: #fff;
    --muted: rgba(255,255,255,0.35); /* 疑似グレー：白の透過 */
    --btn-size: 100px;
  }
  html, body {
    height: 100%;
    margin: 0;
    background: var(--bg);
    color: var(--fg);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans JP", Helvetica, Arial, sans-serif;
    -webkit-font-smoothing: antialiased;
    touch-action: manipulation;
  }
  .app {
    min-height: 100dvh;
    display: grid;
    grid-template-rows: auto 1fr auto;
  }
  header {
    height: 5dvh;
    text-align: center;
    font-size: 20px;
    opacity: 0.8;
    font-family: "Silkscreen";
  }
  header span {
    letter-spacing: .08em;
  }

  /* 2列×5行のプレイヤーレーン */
  .stage {
    display: grid;
    grid-template-columns: 1fr 1fr; /* 左5人・右5人 */
    gap: 0px 16px;
    width: 100dvw;
    padding:0 0 calc(var(--btn-size)/2);
    margin: 0 auto 15px;
  }
  .lane {
    display:flex;
    flex-direction:column;
    height: 100%;    
    justify-content:space-between;
  }
  /* 各行：ボタンとインジケータを内側に寄せる */
  .row {
    display: grid;
    grid-template-columns: 1fr auto; /* 左列用: [ボタン][中央寄りインジケータ] */
    align-items: center;
    height: 100px;
  }
  .row.right {
    grid-template-columns: auto 1fr; /* 右列用: [中央寄りインジケータ][ボタン] */
  }
  
.row.right > .pbtn { justify-self: end; }
.row.right > .indicator { justify-self: end; }

  /* プレイヤーボタン */
  .pbtn {
    appearance: none;
    height: 100%;
    aspect-ratio: 1/1;
    padding:0;
    overflow: hidden;
    background: transparent;
    color: var(--fg);
    border: 2px solid var(--border);
    border-radius: 50%;
    font-family: "Silkscreen";
    font-size: 14px;
    font-weight: 400;
    cursor: pointer;
  box-sizing: border-box;
  }

  /* 文字回転 */
   #lane-right .label {
      display: inline-block;
      transform: rotate(-90deg);
  }
  #lane-left .label {
    display: inline-block;
    transform: rotate(90deg);
  }

  .pbtn:active { transform: scale(0.995); }
  .pbtn[disabled] { cursor: not-allowed; }

  /* エントリー状態（白背景・黒文字） */
  .pbtn.entry {
    background: var(--fg);
    color: var(--bg);
  }

  /* 未エントリーの無効化表現（疑似グレーアウト） */
  .pbtn.inactive {
    opacity: 0.1;
  }
  .pbtn.semi {
  opacity: 0.6; /* ゲーム開始直後〜個別スタート前 */
}


  /* インジケータ（画像or結果テキストを載せる枠） */
  .indicator {
    width: 70px;
    display: grid;
    place-items: center;
  }
  #liner-left .indicator{
    text-align: left;
  }
  #liner-right .indicator{
    text-align: right;
  }
  .indicator img {
    width: 62px;
    height: auto;
    display: block;
    object-fit: contain;
    image-rendering: -webkit-optimize-contrast;
  }
  .result {
    font-family: "Silkscreen";
    display: flex;
    align-items: baseline;
  }
  .result .dec {
  font-size: 0.8em;
}
  .winner {
    font-size: 1.4em;
    color: var(--accent);
    display: flex;
  }

  /* 中央オーバーレイのコントロール（READY/RESET） */
  .center-controls {
    position: fixed;
    left: 50%;
    top: 50%;
    transform: translate(-50%,-50%);
    display: grid;
    gap: 12px;
    z-index: 10;
    pointer-events: none; /* 内部のボタンのみクリックさせる */
  }
    @keyframes spin {
        0%   { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
  .ctrl {
    aspect-ratio: 1/1;
    pointer-events: auto;
    padding: 14px 22px;
    border: none;
    background: rgb(107, 216, 160);
    color: black;
    border-radius: 50%;
    font-size: 18px;
    font-weight: 800;
    font-family: "Silkscreen";
    animation: spin 5s linear infinite;
  }
  .ctrl:active { transform: scale(0.992); }


  /* 視覚的に隠すテキスト（スクリーンリーダー用） */
  .sr-only {
    position: absolute !important;
    width: 1px; height: 1px;
    padding: 0; margin: -1px;
    overflow: hidden; clip: rect(0,0,0,0);
    white-space: nowrap; border: 0;
  }
</style>
</head>
<body>
  <div class="app" id="app">
    <header>
      <span id="headerreset">10SEC CHALLENGE</span>
    </header>
      <div class="stage" id="stage" aria-label="プレイステージ">
        <!-- 左レーン（5人） -->
        <div class="lane" id="lane-left">
          <!-- 5行を生成（JSでもよいが明示で書いておく） -->
          <div class="row">
            <button class="pbtn" data-id="0"><span class="label" >ENTRY?</span></button>
            <div class="indicator" data-ind="0" aria-live="polite"></div>
          </div>
          <div class="row">
            <button class="pbtn" data-id="1"><span class="label" >ENTRY?</span></button>
            <div class="indicator" data-ind="1" aria-live="polite"></div>
          </div>
          <div class="row">
            <button class="pbtn" data-id="2"><span class="label" >ENTRY?</span></button>
            <div class="indicator" data-ind="2" aria-live="polite"></div>
          </div>
          <div class="row">
            <button class="pbtn" data-id="3"><span class="label" >ENTRY?</span></button>
            <div class="indicator" data-ind="3" aria-live="polite"></div>
          </div>
          <div class="row">
            <button class="pbtn" data-id="4"><span class="label" >ENTRY?</span></button>
            <div class="indicator" data-ind="4" aria-live="polite"></div>
          </div>
        </div>

        <!-- 右レーン（5人） -->
        <div class="lane" id="lane-right">
          <div class="row right">
            <div class="indicator" data-ind="5" aria-live="polite"></div>
            <button class="pbtn" data-id="5"><span class="label" >ENTRY?</span></button>
          </div>
          <div class="row right">
            <div class="indicator" data-ind="6" aria-live="polite"></div>
            <button class="pbtn" data-id="6"><span class="label" >ENTRY?</span></button>
          </div>
          <div class="row right">
            <div class="indicator" data-ind="7" aria-live="polite"></div>
            <button class="pbtn" data-id="7"><span class="label" >ENTRY?</span></button>
          </div>
          <div class="row right">
            <div class="indicator" data-ind="8" aria-live="polite"></div>
            <button class="pbtn" data-id="8"><span class="label" >ENTRY?</span></button>
          </div>
          <div class="row right">
            <div class="indicator" data-ind="9" aria-live="polite"></div>
            <button class="pbtn" data-id="9"><span class="label" >ENTRY?</span></button>
          </div>
        </div>
      </div>

      <!-- 中央コントロール -->
      <div class="center-controls" id="center" aria-live="polite"></div>

  </div>

<script>
// ====== 画像データ（Data URL） ======
const IMG_READY = "tool7/ready.png";
const IMG_START = "tool7/start.png";
const IMG_STOP  = "tool7/stop.png";

/* ====== 定数・状態 ====== */
const TARGET_SEC = 10.0;           // 目標10秒
const START_MIN_MS = 3000;         // 3秒
const START_MAX_MS = 6000;         // 6秒

const state = {
  started: false,
  finished: false,
  players: Array.from({length: 10}, (_,i) => ({
    id: i,
    entry: false,
    enabled: true,     // 押下可能か（ゲーム前のみ true）
    startAt: null,     // performance.now()（開始通知時刻）
    stopAt: null,      // performance.now()（ストップ時刻）
    timer: null,       // setTimeout ハンドル
  })),
};

let assetsReady = false;
const ASSETS = [IMG_READY, IMG_START, IMG_STOP];

async function preloadAssets() {
  await Promise.all(ASSETS.map((src) => {
    const img = new Image();
    img.fetchPriority = "high";  // 可能なら高優先度
    img.decoding = "sync";       // 直ちにデコード
    img.src = src;
    // decode() が使えない古い環境は onload にフォールバック
    return img.decode ? img.decode().catch(() => new Promise(res => img.onload = res))
                      : new Promise(res => img.onload = res);
  }));
  assetsReady = true;
  updateReadyVisibility(); // READY の状態を更新
}


const center = document.getElementById('center');
const buttons = Array.from(document.querySelectorAll('.pbtn'));
const indicators = Array.from(document.querySelectorAll('.indicator'));

/* ====== ユーティリティ ====== */
const between = (min, max) => Math.random() * (max - min) + min;
const ms = () => performance.now();

function updateReadyVisibility() {
  if (state.started || state.finished) { center.innerHTML = ""; return; }
  const entries = state.players.filter(p => p.entry).length;
  if (entries >= 2) {
    center.innerHTML = `<button class="ctrl" id="btn-ready" aria-label="ゲーム開始">READY</button>`;
    document.getElementById('btn-ready').onclick = startGame;
  } else {
    center.innerHTML = "";
  }
}

// ← 既存関数を置き換え
    function setButtonVisual(p) {
    const btn = buttons[p.id];
    btn.classList.toggle('entry', p.entry);
    btn.disabled = !p.enabled;

    // ラベル文字を状態に応じて決定
    let text;
    if (p.stopAt != null) {
        text = "STOP";         // 押した直後の表示（変更可）
    } else if (p.startAt != null) {
        text = "START";        // タイマー開始後〜停止まで
    } else if (p.entry) {
        text = "READY";        // エントリー済み（未開始）
    } else {
        text = "ENTRY?";       // 未エントリー
    }

    const label = btn.querySelector('.label');
    if (label) label.textContent = text;
    else btn.textContent = text;
}


function setInactive(p, inactive) {
  const btn = buttons[p.id];
  btn.classList.toggle('inactive', !!inactive);
}

function setIndicatorToImage(id, src, alt) {
  const ind = indicators[id];
  ind.innerHTML = "";
  const img = document.createElement('img');
  img.src = src;
  img.alt = alt || "";
  ind.appendChild(img);
}

function setIndicatorToResult(id, sec, isWinner=false) {
  const ind = indicators[id];
  ind.innerHTML = "";
  const span = document.createElement('span');
  span.className = 'result' + (isWinner ? ' winner' : '');

  const text = sec.toFixed(2);
  const [intPart, decPart] = text.split(".");
  span.innerHTML = `${intPart}.<span class="dec">${decPart}</span>`;

  ind.appendChild(span);
}


/* ====== 事前：エントリートグル ====== */
buttons.forEach(btn => {
  btn.addEventListener('click', () => {
    const id = Number(btn.dataset.id);
    const p = state.players[id];
    if (state.started || state.finished) return; // ゲーム中は無視
    p.entry = !p.entry; // トグル
    setButtonVisual(p);
    updateReadyVisibility();
  }, { passive: true });
});

/* ====== ゲーム開始 ====== */
function startGame() {
  if (state.started) return;
  state.started = true;
  center.innerHTML = ""; // READYボタン消滅

  // 1) 未エントリーは無効化＋見た目減透明
  state.players.forEach(p => {
    if (!p.entry) {
      p.enabled = false;
      setButtonVisual(p);
      setInactive(p, true);
    }
  });

  // 2) エントリー済は一旦無効化（押せない）
  const entries = state.players.filter(p => p.entry);
  entries.forEach(p => {
    p.enabled = false;
    setButtonVisual(p);
    const btn = buttons[p.id];
    btn.classList.add('semi');
    setIndicatorToImage(p.id, IMG_READY, "READY");
  });

  // 3) 各プレイヤーに 3〜6秒のランダム遅延で開始を割り当て
  const base = ms();
  entries.forEach(p => {
    const delay = between(START_MIN_MS, START_MAX_MS);
    p.timer = setTimeout(() => {
      p.startAt = ms();          // 内部カウント開始
      p.enabled = true;          // このプレイヤーのみ有効化
        const btn = buttons[p.id];
        btn.classList.remove('semi');
      setButtonVisual(p);
      setIndicatorToImage(p.id, IMG_START, "START");
    }, delay);
  });

  // 4) 各プレイヤーボタンの押下でストップ処理
  buttons.forEach(btn => {
    btn.onclick = () => {
      const id = Number(btn.dataset.id);
      const p = state.players[id];
      // 参加していない・未開始・すでに停止済みは無視
      if (!p.entry) return;
      if (!p.enabled) return;      // 未開始や無効状態は押せない
      if (p.stopAt != null) return;

      // ストップ
      p.stopAt = ms();
      p.enabled = false;           // 「複数回押し」対策：以降無効化
        const btnb = buttons[p.id];
        btnb.classList.add('semi');
      setButtonVisual(p);
      setIndicatorToImage(p.id, IMG_STOP, "STOP");

      // 全員停止チェック
      const allStopped = state.players
        .filter(pp => pp.entry)
        .every(pp => pp.stopAt != null);
      if (allStopped) {
        showResults();
      }
    };
  });
}

/* ====== 結果表示 ====== */
function showResults() {
  if (state.finished) return;
  state.finished = true;

  // 各プレイヤーの秒数を算出（startAt〜stopAt）
  const entries = state.players.filter(p => p.entry);
  const results = entries.map(p => {
    const sec = (p.stopAt - p.startAt) / 1000;
    const err = Math.abs(sec - TARGET_SEC);
    return { id: p.id, sec, err };
  });

  // 最小誤差
  const minErr = Math.min(...results.map(r => r.err));

  // 画像を隠し、秒数（小数2桁）を表示。最小誤差を赤で強調
  results.forEach(r => {
    const text = r.sec.toFixed(2);
    const isWinner = Math.abs(r.err - minErr) < 1e-9; // 浮動小数誤差対策
    setIndicatorToResult(r.id, r.sec, isWinner);
  });

  // 中央に RESET を出す
  document.getElementById('headerreset').innerHTML = `<span id="btn-reset" >RESET</button>`;
  document.getElementById('btn-reset').onclick = () => location.reload();
}

/* ====== 初期UI適用 ====== */
preloadAssets();
updateReadyVisibility();
state.players.forEach(setButtonVisual);

</script>
</body>
</html>
